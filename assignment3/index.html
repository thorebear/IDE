<!DOCTYPE html>
<html>

<head>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>   

  <!-- BOOTSTRAP CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">

  <!-- JQUERY -->
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  <!-- BOOSTRAP JS -->
  <!-- Latest compiled and minified JavaScript -->
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

  <!-- D3 -->
  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

  <!-- C3 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.js"></script>

  <!-- Our CSS -->
  <style>
  div.container {
    width: 1200;
  }
  .graph {
    padding: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin: 0;
    margin-top: 0;
    margin-bottom: 0;
  }
  .axis path,
  .axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
  }
  .axis text {
    font-family: sans-serif;
    font-size: 11px;
  }

  </style>

  <title>Interactive Data Exploration - Assignment 3</title>

</head>

<body>

  <div class="jumbotron" id="home">
    <div class="container text-center">
      <h1>Assignment 3</h1>      
      <h3> - By Thorbj√∏rn Christensen and Mads Thoudahl</h3>
    </div>
  </div>

  <div class="container">

    <div class="col-sm-4" class="graph">
      <div id="pcagraph" class="graph"> 
        <noscript> Please turn on JavaScript to display svg here </noscript>
      </div>
      <div id="infograph" class="graph"> 
        <noscript> Please turn on JavaScript to display svg here </noscript>
      </div>
    </div>

    <div class="col-sm-8" class="graph">
      <div id="handgraph" class="graph"> 
        <noscript> Please turn on JavaScript to display svg here </noscript>
      </div>
    </div>   

  </div>

  <!-- Our javascript -->
  <script type="text/javascript">
    /* Initialize variables */

    var w, bw, h, bh, padding, circleradius, hoverradius;       
    var handdata, pcadata, info;  /* Handles to datasets    */
    var handmin, handmax, pcamin, pcamax;
    var infosvg, pcasvg, handsvg; /* Handles to svg figures */
    var sxScale, syScale, bxScale, byScale;

    /* Set sizes */
    w       = 300;
    h       = 250;
    bw      = 2*w;
    bh      = 2*h;
    padding = 30;

    /* really style defs... should they be moved ? */
    circleradius   = 3;
    hoverradius    = 5;
    selectioncolor = "red";

    /* It all begins */
    d3.select(window).on("load", init);

    /* load data and initialize the svg canvasses */
    function init(){ 

      d3.text("hands_pca.csv", function(text){
        var rows  = d3.csv.parseRows(text);
        pcadata   = rows.map(function(rowt){
                             return rowt.map(parseFloat);  
        });

        /* var minx, maxx, miny, maxy; */
        minx = d3.min(pcadata, function(d){return d[0]});
        maxx = d3.max(pcadata, function(d){return d[0]});
        miny = d3.min(pcadata, function(d){return d[1]});
        maxy = d3.max(pcadata, function(d){return d[1]});

        sxScale = d3.scale.linear()
          .domain([minx, maxx])
          .range([padding, w-padding]);

        syScale = d3.scale.linear()
          .domain([miny, maxy])
          .range([h-padding, padding]);

        buildPcaGraph(pcadata);
      });


      d3.text("hands.csv", function(text){
        rowstxt = d3.csv.parseRows(text);
        rows    = rowstxt.map(function(row){
                              return row.map(parseFloat);  
        });

         xrows = rows.map( function(row)
            {return row.slice( 0, Math.floor(row.length/2))});
         yrows = rows.map( function(row)
            {return row.slice( Math.floor(row.length/2), row.length)});
        xs    = xrows.reduce(function(a,b){return a.concat(b)});
        ys    = yrows.reduce(function(a,b){return a.concat(b)});

        var minx, maxx, miny, maxy;
        minx  = d3.min(xs);
        maxx  = d3.max(xs);
        miny  = d3.min(ys);
        maxy  = d3.max(ys);

        handdata  = rows.map(zipRow);

        bxScale   = d3.scale.linear()
                            .domain([minx, maxx])
                            .range([padding, bw-padding]);

        byScale   = d3.scale.linear()
                            .domain([miny, maxy])
                            .range([bh-padding, padding]);

        buildHandGraph(handdata);
      });


      buildInfoGraph();

    };


    function buildPcaGraph(pca,i){
      var bg, xAxis, yAxis, cs;

      /* create svg and assign to handle */
      pcasvg = d3.select("#pcagraph")
        .append("svg")
        .attr("width",w)
        .attr("height",h);

      /* create a canvas background */
      bg = pcasvg
        .append("rect")
        .attr("width","100%")
        .attr("height","100%")
        .attr("fill","white")
        .attr("stroke-width","1px")
        .attr("stroke","black");

      /* create axes */
      xAxis = d3.svg
        .axis()
        .scale(sxScale)
        .orient("bottom")
        .ticks(5);

      yAxis = d3.svg
        .axis()
        .scale(syScale)
        .orient("left")
        .ticks(5);

      pcasvg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(0,"+(h-padding)+")")
        .call(xAxis);

      pcasvg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate("+padding+",0)")
        .call(yAxis);

      pcasvg.append("text")
        .attr("class", "text")
        .attr("class", "title")
        .attr("x", ((sxScale.range()[1]-sxScale.range()[0] )/2 + padding)+"")
        .attr("y", syScale.range()[1]+"")
        .attr("style", "text-anchor:middle")
        .text("1st Principal Component");

      pcasvg.append("text")
        .attr("class", "text")
        .attr("transform", "translate("+(sxScale.range()[1] + padding*0.5)+","+(h-padding-(syScale.range()[0]-syScale.range()[1])/2)+")rotate(-90)")
        .attr("style", "text-anchor:middle")
        .text("2nd Principal Component");

      /* create a circle for each datapoint in the dataset */
      cs = pcasvg
        .selectAll("circle")
        .data(pca)
        .enter()
        .append("circle")
        .attr("cx", function(d){ return sxScale(d[0]);})
        .attr("cy", function(d){ return h-syScale(d[1]);})
        .attr("r",circleradius);
            
      cs.on("mousemove", function(d,idx){
        cs.attr('r', function(d,i){ 
            if(idx===i) return hoverradius;
            else return circleradius;
          })
        });

      cs.on("mouseleave", function(d){
        cs.attr('r', function(d){ 
            return circleradius;
          })
        });

      cs.on("click", function(d,idx){
        cs.attr('r', function(d,i){ 
            if(idx===i) return hoverradius;
            else return circleradius;
          })
          .attr('fill', function(d,i){ 
            if(idx===i) return selectioncolor;
            else return 'black';
          });

        updateHand(idx);
        });

      /* unselect - resetting the environment */
      bg.on("click", function(d){
        cs.attr('r', function(d){ 
            return circleradius;
          })
          .attr('fill', function(d){ 
            return 'black';
          });

        updateHand(0);
        
        });

    };

  function updateHand(i){
     d3.select("#handoutline").remove()
     
      /* purpose is to redraw the hand in the handsvg based on index*/
      var points = handsvg.selectAll('circle')
        .data(handdata[i], function(d){ return d});

      /* update points via a smooth transition */
      points.transition()
        .delay(100)
        .duration(1000)
        .attr('cx',function(d){return bxScale(d[0]);})
        .attr('cy',function(d){return byScale(d[1]);})
        .style("fill", "red");

      /* enter new points */
      points.enter()
        .append('circle')
        .attr('cx',bw/2)
        .attr('cy',bh/2)
        .attr('r',circleradius)
        .transition()
        .delay(500)
        .duration(500)
        .attr('cx',function(d){return bxScale(d[0]);})
        .attr('cy',function(d){return byScale(d[1]);});

      /* remove exiting (old) points */
      points.exit()
        .transition()
        .duration(500)
        .attr('cx',bw/2)
        .attr('cy',bh/2)
        .remove();

       var lineFn = d3.svg.line()
          .x(function(d) { return bxScale(d[0]); })
          .y(function(d) { return byScale(d[1]); })
          .interpolate("cardinal-closed")
          .tension(0.8);
       
     var lineGraph = d3.select("#handsvg").append("path")
        .transition()
        .duration(500)
        .attr("id", "handoutline")
        .attr("d", lineFn(handdata[i] ) )
        .attr("stroke", "blue")
        .attr("stroke-width", 2)
        .attr("fill", "pink")
        .attr("opacity", "0.6");
       
      return points;
    };

    function buildInfoGraph(){
      console.log('buildInfoGraph Not Implemented')
      /* create svg and assign to handle */
      infosvg = d3.select("#infograph")
        .append("svg")
        .attr("width",w)
        .attr("height",h)

      infosvg.append("rect")
        .attr("width","100%")
        .attr("height","100%")
        .attr("fill","white")
        .attr("stroke-width","1px")
        .attr("stroke","black");
    };


    function buildHandGraph(d,i){
      console.log('buildHandGraph Not Implemented')
      /* create svg and assign to handle */
      handsvg = d3.select("#handgraph")
         .append("svg")
         .attr("id", "handsvg")
        .attr("width",bw)
        .attr("height",bh);

      handsvg.append("rect")
        .attr("width","100%")
        .attr("height","100%")
        .attr("fill","white")
        .attr("stroke-width","1px")
        .attr("stroke","black");

      /* insert a static set of points */
      var points = updateHand(0);
      /*var points = handsvg.selectAll('circle')
        .data(handdata[0])
        .enter()
        .append('circle')
        .attr('cx',function(d){return bxScale(d[0]);})
        .attr('cy',function(d){return byScale(d[1]);})
        .attr('r',circleradius); */

      /* insert a static path between the points - NOWORK? */
      

    };


    function zipRow(row){
      var xs   = row.slice( 0, Math.floor(row.length/2));
      var ys   = row.slice( Math.floor(row.length / 2), row.length);
      return d3.zip( xs, ys );
    };

  </script>

</body>

</html>

<!DOCTYPE html>
<html>

<head>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>   

  <!-- BOOTSTRAP CSS -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">

  <!-- JQUERY -->
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  <!-- BOOSTRAP JS -->
  <!-- Latest compiled and minified JavaScript -->
  <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>

  <!-- D3 -->
  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

  <!-- C3 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.js"></script>

  <!-- Our CSS -->
  <style>
  div.container {
    width: 1200;
  }
  .graph {
    padding: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin: 0;
    margin-top: 0;
    margin-bottom: 0;
  }
  .axis path,
  .axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
  }
  .axis text {
    font-family: sans-serif;
    font-size: 11px;
  }

  </style>

  <title>Interactive Data Exploration - Assignment 3</title>

</head>

<body>

  <div class="jumbotron" id="home">
    <div class="container text-center">
      <h1>Assignment 3</h1>      
      <h3> - By Thorbj√∏rn Christensen and Mads Thoudahl</h3>
    </div>
  </div>

  <div class="container">

    <div class="col-sm-4" class="graph">
      <div id="pcagraph" class="graph"> 
        <noscript> Please turn on JavaScript to display svg here </noscript>
      </div>
      <div id="infograph" class="graph"> 
        <noscript> Please turn on JavaScript to display svg here </noscript>
      </div>
    </div>
    
    <div class="col-sm-8" class="graph">
      <div id="handgraph" class="graph"> 
        <noscript> Please turn on JavaScript to display svg here </noscript>
      </div>
    </div>   

  </div>

  <!-- Our javascript -->
  <script type="text/javascript">
    /* Initialize variables */

    var w, bw, h, bh, padding, circleradius, hoverradius;       
    var handdata, pcadata, avghand, expsdev, nohand;  /* Handles to datasets    */
    var handmin, handmax, pcamin, pcamax;
    var infosvg, pcasvg, handsvg; /* Handles to svg figures */
  var sxScale, syScale, bxScale, byScale, color;
  var xScale, yScale;
    var pcs, isOn;

    /* Set sizes */
    w       = 300;
    h       = 250;
    bw      = 2*w;
    bh      = 2*h;
    padding = 30;

    /* list of principal components being investigated (max is 8) */
    pcs     = d3.range(1,(6+1));
    nohand  = [];

    /* storing state for buttons */
    isOn    = d3.map({});
    for  (i = 1; i <= pcs.length; i++) { isOn.set(i, false); };


    /* really style defs... should they be moved ? */
    color = d3.scale.category10();
    circleradius   = 2;
    hoverradius    = 5;
    selectioncolor = "red";

    /* It all begins */
    d3.select(window).on("load", init);

    /* load data and initialize the svg canvasses */
    function init(){ 

      d3.text("hands_pca.csv", function(text){
        var rows  = d3.csv.parseRows(text);
        pcadata   = rows.map(function(rowt){
                             return rowt.map(parseFloat);  
        });

        /* var minx, maxx, miny, maxy; */
        var minx = d3.min(pcadata, function(d){return d[0]});
        var maxx = d3.max(pcadata, function(d){return d[0]});
        var miny = d3.min(pcadata, function(d){return d[1]});
        var maxy = d3.max(pcadata, function(d){return d[1]});

        sxScale = d3.scale.linear()
          .domain([minx, maxx])
          .range([padding, w-padding]);

        syScale = d3.scale.linear()
          .domain([miny, maxy])
          .range([h-padding, padding]);

        buildPcaGraph(pcadata);
      });


      d3.text("hands.csv", function(text){
        rowstxt = d3.csv.parseRows(text);
        rows    = rowstxt.map(function(row){
                              return row.map(parseFloat);  
        });

        xrows = rows.map( function(row){return row.slice( 0, Math.floor(row.length/2))});
        yrows = rows.map( function(row){return row.slice( Math.floor(row.length/2), row.length)});
        xs    = xrows.reduce(function(a,b){return a.concat(b)});
        ys    = yrows.reduce(function(a,b){return a.concat(b)});

        var minx, maxx, miny, maxy;
        minx  = d3.min(xs);
        maxx  = d3.max(xs);
        miny  = d3.min(ys);
        maxy  = d3.max(ys);

        xScale    = d3.scale.linear()
          .domain([minx, maxx])
          .range([padding, w-padding]);

        yScale    = d3.scale.linear()
          .domain([miny, maxy])
          .range([h-padding, padding]);

        handdata  = rows.map(zipRow);

        bxScale   = d3.scale.linear()
          .domain([minx, maxx])
          .range([padding, bw-padding]);

        byScale   = d3.scale.linear()
          .domain([miny, maxy])
          .range([bh-padding, padding]);

        buildHandGraph();

      });


      d3.text("hands_syn.csv", function(text){
        var rowstxt = d3.csv.parseRows(text);
        var rows    = rowstxt.map(function(row){
                              return row.map(parseFloat);  
        });

        avghand   = zipRow(rows[0]);
        expsdev   = rows[1];
        pcsdata   = rows.slice(2).map(zipRow);
        
        var xrows = rows.slice(2).map( function(row){return row.slice( 0, Math.floor(row.length/2))});
        var yrows = rows.slice(2).map( function(row){return row.slice( Math.floor(row.length/2), row.length)});
        var xs    = xrows.reduce(function(a,b){return a.concat(b)});
        var ys    = yrows.reduce(function(a,b){return a.concat(b)});

        buildInfoGraph(avghand,expsdev,pcsdata);

      });

    };


    function buildPcaGraph(pca,i){
      var bg, xAxis, yAxis, cs;

      /* create svg and assign to handle */
      pcasvg = d3.select("#pcagraph")
        .append("svg")
        .attr("width",w)
        .attr("height",h);

      /* create a canvas background */
      bg = pcasvg
        .append("rect")
        .attr("width","100%")
        .attr("height","100%")
        .attr("fill","white")
        .attr("stroke-width","1px")
        .attr("stroke","black");

      /* create axes */
      xAxis = d3.svg
        .axis()
        .scale(sxScale)
        .orient("bottom")
        .ticks(5);

      yAxis = d3.svg
        .axis()
        .scale(syScale)
        .orient("left")
        .ticks(5);

      pcasvg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(0,"+(h-padding)+")")
        .call(xAxis);

      pcasvg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate("+padding+",0)")
        .call(yAxis);

      pcasvg.append("text")
        .attr("class", "text")
        .attr("class", "title")
        .attr("x", ((sxScale.range()[1]-sxScale.range()[0] )/2 + padding)+"")
        .attr("y", syScale.range()[1]+"")
        .attr("style", "text-anchor:middle")
        .text("1st Principal Component");

      pcasvg.append("text")
        .attr("class", "text")
        .attr("transform", "translate("+(sxScale.range()[1] + padding*0.5)+","+(h-padding-(syScale.range()[0]-syScale.range()[1])/2)+")rotate(-90)")
        .attr("style", "text-anchor:middle")
        .text("2nd Principal Component");

      /* create a circle for each datapoint in the dataset */
      cs = pcasvg
        .selectAll("circle")
        .data(pca)
        .enter()
        .append("circle")
        .attr("cx", function(d){ return sxScale(d[0]);})
        .attr("cy", function(d){ return h-syScale(d[1]);})
        .attr("r",circleradius);
            
      cs.on("mousemove", function(d,idx){
        cs.attr('r', function(d,i){ 
            if(idx===i) return hoverradius;
            else return circleradius;
          })
        });

      cs.on("mouseleave", function(d){
        cs.attr('r', function(d){ 
            return circleradius;
          })
        });

      cs.on("click", function(d,idx){
        cs.attr('r', function(d,i){ 
            if(idx===i) return hoverradius;
            else return circleradius;
          })
          .attr('fill', function(d,i){ 
            if(idx===i) return selectioncolor;
            else return 'black';
          });

        updateHand(handdata, idx);
        });

      /* unselect - resetting the environment */
      bg.on("click", function(d){
        cs.attr('r', function(d){ 
            return circleradius;
          })
          .attr('fill', function(d){ 
            return 'black';
          });

        updateHand(handdata, 0); /* [avghand] */
        
        });

    };

  function updateHand(data, i){
     d3.select("#handoutline").remove()
     
      /* purpose is to redraw the hand in the handsvg based on index*/
      var points = handsvg.selectAll('circle')
        .data(data[i], function(d){ return d});

      /* update points via a smooth transition */
      points.transition()
        .delay(100)
        .duration(1000)
        .attr('cx',function(d){return bxScale(d[0]);})
        .attr('cy',function(d){return byScale(d[1]);})
        .style("fill", "red");

      /* enter new points */
      points.enter()
        .append('circle')
        .attr('cx',bw/2)
        .attr('cy',bh/2)
        .attr('r',circleradius)
        .transition()
        .delay(500)
        .duration(500)
        .attr('cx',function(d){return bxScale(d[0]);})
        .attr('cy',function(d){return byScale(d[1]);});

      /* remove exiting (old) points */
      points.exit()
        .transition()
        .duration(500)
        .attr('cx',bw/2)
        .attr('cy',bh/2)
        .remove();

       var lineFn = d3.svg.line()
          .x(function(d) { return bxScale(d[0]); })
          .y(function(d) { return byScale(d[1]); })
          .interpolate("cardinal-closed")
          .tension(0.8);
       
     var lineGraph = d3.select("#handsvg").append("path")
        .transition()
        .duration(500)
        .attr("id", "handoutline")
        .attr("d", lineFn(handdata[i] ) )
        .attr("stroke", "blue")
        .attr("stroke-width", 2)
        .attr("fill", "pink")
        .attr("opacity", "0.6");
       
      return points;
    };


  function drawInfoHand(hand, name, col){
     if (hand.length === 0){
        infosvg.selectAll('.' + name).remove();
     }
      /* purpose is to redraw the hand in the infosvg based on index*/
      var points = infosvg.selectAll('circle.'+name)
        .data(hand, function(d){ return d});

      var head = 1;
      /* update points via a smooth transition */
       /*
       points.transition() 
        .delay(100)
        .duration(1000)
        .attr('cx',function(d){ return xScale(d[1][head][0]);})
        .attr('cy',function(d){ return yScale(d[1][head][1]);})
        .style("fill", "red");


      points.enter()
        .append('circle')
        .attr('class',name)
        .attr('cx',w/2)
        .attr('cy',h/2)
        .attr('r',circleradius)
        .style("fill", col)
        .transition()
        .delay(500)
        .duration(1000)
        .attr('cx',function(d){return xScale(d[1][head][0]);})
        .attr('cy',function(d){return yScale(d[1][head][1]);})
         .each('end', function(){ move(this, head); });
       */


       var lineFn2 = d3.svg.line()
          .x(function(d) { return xScale(d[1][head][0]); })
          .y(function(d) { return yScale(d[1][head][1]); })
          .interpolate("cardinal-closed")
          .tension(0.8);

       drawOutline();
       
       function drawOutline(){
          var lineGraph = infosvg.append("path")
             .attr("d", lineFn2(hand ) )
             .attr("stroke-width", 0)
             .attr("fill", col)
             .attr("class", name)
             .attr("opacity", "0.6");
          updateOutline();
          function updateOutline(){
             head = (head + 1) % 2;
             lineGraph
                .transition()
                .duration(3000)
                .delay(500)
                .attr("d", lineFn2(hand))
                .each("end", updateOutline)
          };
       };
       
      /* remove exiting (old) points */
      points.exit()
        .transition()
        .duration(1000)
        .attr('cx',w/2)
        .attr('cy',h/2)
        .remove();

      function move(el, head){
        var nexthead;
        if (head===0) {nexthead=1;} else {nexthead=0;}
        d3.select(el)
          .transition()
          .delay(500)
          .duration(1000)
          .attr('cx',function(d){ return xScale(d[1][head][0]);})
          .attr('cy',function(d){ return yScale(d[1][head][1]);})
          .each('end', function(){ 
            move(el, nexthead); 
          });  
      };

    };



    function buildInfoGraph(avghand,expsdev,pcsdata){
      console.log('buildInfoGraph is being implemented')
      /* create svg and assign to handle */
      infosvg = d3.select("#infograph")
        .append("svg")
        .attr("width",w)
        .attr("height",h);

      infosvg.append("rect")
        .attr("width","100%")
        .attr("height","100%")
        .attr("fill","white")
        .attr("stroke-width","1px")
        .attr("stroke","black");

      drawInfoHand( d3.zip(d3.range(avghand.length), d3.zip(avghand,avghand)), "avg", "black");

      var buttons = infosvg.selectAll("rect.pcbutton")
        .data(pcs)
        .enter()
        .append("rect")
        .attr("class","pcbutton")
        .attr("class","pc" + function(d){return d})
        .attr("x", function(d,i){ return (i+2)*padding})
        .attr("y","1")
        .attr("width",padding)
        .attr("height",padding)
        .attr("fill", function(d,i){ return color(i)})
        .attr("stroke-width","1px")
        .attr("stroke","black")
        .attr("opacity", "0.5");

      var buttontexts = infosvg.selectAll("text.pcbutton")
        .data(pcs)
        .enter()
        .append("text")
        .attr("class","pcbutton")
        .attr("x", function(d,i){ return (d+1.5)*padding})
        .attr("y",0.75*padding)
        .attr("text-anchor","middle")
        .text(function(d){return d});

      buttons.on("click", function(d,i){
            var pchands = d3.zip( d3.range(pcsdata[d].length), d3.zip(pcsdata[d], pcsdata[d+pcsdata.length/2]) ); 
            /* switch on/off */
            if (isOn.get(d)) {
              /* shut down */
              isOn.set(d,false);
              d3.select(this)
                .attr('opacity', "0.5");
              drawInfoHand(nohand, "pc"+d, "black");
            } else {
              /* start up */
              isOn.set(d,true);
              d3.select(this)
                .attr('opacity', "1.0");
              drawInfoHand(pchands, "pc"+d, color(i));

              /*
              var head = 0;
              while (isOn.get(d)) {                

              if (head===0) {
                head = 1;
                drawInfoHand(pcplus, "pc"+d);
              } else { 
                head = 0;
                drawInfoHand(pcminus, "pc"+d);
              }
              */
            }
        });
    };


    function buildHandGraph(){
      /* create svg and assign to handle */
      handsvg = d3.select("#handgraph")
        .append("svg")
        .attr("id", "handsvg")
        .attr("width",bw)
        .attr("height",bh);

      handsvg.append("rect")
        .attr("width","100%")
        .attr("height","100%")
        .attr("fill","white")
        .attr("stroke-width","1px")
        .attr("stroke","black");

      /* insert a static set of points */
      var points = updateHand(handdata,0); /*[avghand]*/

      /* insert a static path between the points - NOWORK? */
      

    };


    function zipRow(row){
      var xs   = row.slice( 0, Math.floor(row.length/2));
      var ys   = row.slice( Math.floor(row.length / 2), row.length);
      return d3.zip( xs, ys );
    };

  </script>

</body>

</html>
